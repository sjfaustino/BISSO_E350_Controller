"use strict"; const Utils = { setText(t, e) { const i = document.getElementById(t); return !!i && (i.textContent = e, !0) }, setValue(t, e) { const i = document.getElementById(t); return !!i && (i.value = e, !0) }, setStyle(t, e, i) { const s = document.getElementById(t); return !!s && (s.style[e] = i, !0) }, getElement: t => document.getElementById(t), updateElements(t) { for (const [e, i] of Object.entries(t)) this.setText(e, i) }, debounce(t, e) { let i; return function (...s) { clearTimeout(i), i = setTimeout(() => t(...s), e) } }, throttle(t, e) { let i; return function (...s) { i || (t.apply(this, s), i = !0, setTimeout(() => i = !1, e)) } }, formatBytes(t, e = 2) { if (0 === t) return "0 Bytes"; const i = e < 0 ? 0 : e, s = Math.floor(Math.log(t) / Math.log(1024)); return parseFloat((t / Math.pow(1024, s)).toFixed(i)) + " " + ["Bytes", "KB", "MB", "GB"][s] }, formatDuration(t) { const e = Math.floor(t / 1e3), i = Math.floor(e / 60), s = Math.floor(i / 60), n = Math.floor(s / 24); return n > 0 ? `${n}d ${s % 24}h` : s > 0 ? `${s}h ${i % 60}m` : i > 0 ? `${i}m ${e % 60}s` : `${e}s` }, clamp: (t, e, i) => Math.min(Math.max(t, e), i), escapeHtml(t) { const e = document.createElement("div"); return e.textContent = t, e.innerHTML }, fetchWithAuth(t, e = {}) { return fetch(t, e) } }; window.Utils = Utils; class AppState { static data = { system: { status: "INITIALIZING", health: "unknown", cpu_percent: 0, free_heap_bytes: 0, firmware_version: "--", uptime_seconds: 0, plc_hardware_present: !1 }, motion: { position: { x: 0, y: 0, z: 0, a: 0 }, moving: !1, status: "STOPPED" }, safety: { estop: !1, alarm: !1 }, vfd: { current_amps: 0, frequency_hz: 0, thermal_percent: 0, fault_code: 0, stall_threshold: 0, calibration_valid: !1, connected: !1 }, axis: { x: { quality: 0, jitter_mms: 0, stalled: !1, vfd_error_percent: 0 }, y: { quality: 0, jitter_mms: 0, stalled: !1, vfd_error_percent: 0 }, z: { quality: 0, jitter_mms: 0, stalled: !1, vfd_error_percent: 0 } }, encoders: [], network: { wifi_connected: !1, signal_percent: 0 }, load_state: 0, performance: { tasks: [] }, ota: { available: !1, latest_version: "", download_url: "", release_notes: "" }, config: { http_auth: !0, https: !1, websocket: !0, modbus: !1 } }; static listeners = []; static history = []; static maxHistory = 1440; static update(t) { this.data = this.deepMerge(this.data, t), Math.random() < .1 && this.recordHistory(), this.notifyListeners("state-changed") } static get(t) { return this.getNestedValue(this.data, t) } static set(t, e) { this.setNestedValue(this.data, t, e), this.notifyListeners("state-changed") } static subscribe(t) { return this.listeners.push(t), () => { this.listeners = this.listeners.filter(e => e !== t) } } static deepMerge(t, e) { const i = { ...t }; for (const s in e) e[s] && "object" == typeof e[s] && !Array.isArray(e[s]) ? i[s] = this.deepMerge(t[s] || {}, e[s]) : i[s] = e[s]; return i } static getNestedValue(t, e) { return e.split(".").reduce((t, e) => t?.[e], t) } static setNestedValue(t, e, i) { const s = e.split("."), n = s.pop(); s.reduce((t, e) => t[e] = t[e] || {}, t)[n] = i } static async checkForUpdates() { try { const t = await fetch("/api/ota/latest"); if (t.ok) { const e = await t.json(); if (this.update({ ota: e }), e.available) this.showUpdateBanner(e); else { const t = document.getElementById("ota-update-banner"); t && t.classList.add("hidden") } } } catch (t) { console.error("[OTA] Failed to check for updates:", t) } } static showUpdateBanner(t) { const e = document.getElementById("ota-update-banner"); e && (e.innerHTML = `\n                <div class="ota-content">\n                    <span class="ota-icon">ðŸš€</span>\n                    <span class="ota-text">\n                        <strong>Update Available:</strong> PosiPro ${t.latest_version || "v?.?.?"} is ready to install.\n                    </span>\n                    <div class="ota-actions">\n                        <button class="btn btn-sm btn-light" onclick="Router.go('system')">View Details</button>\n                    </div>\n                </div>\n            `, e.classList.remove("hidden")) } static recordHistory() { this.history.push({ timestamp: Date.now(), data: JSON.parse(JSON.stringify(this.data)) }), this.history.length > this.maxHistory && this.history.shift() } static getHistory(t = 60) { const e = Date.now() - 60 * t * 1e3; return this.history.filter(t => t.timestamp > e) } static notifyListeners(t) { window.dispatchEvent(new CustomEvent(t, { detail: this.data })) } static reset() { this.data = { ...this.constructor.data }, this.history = [], this.notifyListeners("state-reset") } } window.AppState = AppState; window.addEventListener("telemetry", t => AppState.update(t.detail));
class ThemeManager { static themes = ["light", "dark", "high-contrast", "colorblind"]; static currentTheme = "light"; static settings = { theme: "light", fontSize: 100, gridLines: !1, dualAxis: !0, soundAlerts: !0, autoRefresh: !0 }; static init() { this.loadSettings(), this.applyTheme(this.currentTheme), this.setFontSize(this.settings.fontSize) } static loadSettings() { const t = localStorage.getItem("app-settings"); if (t) try { this.settings = { ...this.settings, ...JSON.parse(t) }, this.currentTheme = this.settings.theme } catch (t) { } } static saveSettings() { localStorage.setItem("app-settings", JSON.stringify(this.settings)) } static applyTheme(t) { this.themes.includes(t) && (document.documentElement.setAttribute("data-theme", t), document.body.className = "", "dark" === t ? document.body.classList.add("dark-theme") : "high-contrast" === t ? document.body.classList.add("high-contrast") : "colorblind" === t && document.body.classList.add("colorblind-mode"), this.currentTheme = t, this.settings.theme = t, this.saveSettings()) } static setFontSize(t) { this.settings.fontSize = Math.max(80, Math.min(120, t)), document.documentElement.style.fontSize = this.settings.fontSize / 100 * 16 + "px", this.saveSettings() } static getSettings() { return { ...this.settings } } static getCurrentTheme() { return this.currentTheme } } class Router { static routes = { dashboard: { file: "pages/dashboard/dashboard.html", js: "pages/dashboard/dashboard.js" }, gcode: { file: "pages/gcode/gcode.html", js: "pages/gcode/gcode.js" }, "cut-planner": { file: "pages/cut-planner/cut-planner.html", js: "pages/cut-planner/cut-planner.js" }, motion: { file: "pages/motion/motion.html", js: "pages/motion/motion.js" }, homing: { file: "pages/homing/homing.html", js: "pages/homing/homing.js" }, diagnostics: { file: "pages/diagnostics/diagnostics.html", js: "pages/diagnostics/diagnostics.js" }, network: { file: "pages/network/network.html", js: "pages/network/network.js" }, system: { file: "pages/system/system.html", js: "pages/system/system.js" }, maintenance: { file: "pages/maintenance/maintenance.html", js: "pages/maintenance/maintenance.js" }, logs: { file: "pages/logs/logs.html", js: "pages/logs/logs.js" }, hardware: { file: "pages/hardware/hardware.html", js: "pages/hardware/hardware.js" }, settings: { file: "pages/settings/settings.html", js: "pages/settings/settings.js" } }; static currentPage = null; static currentModule = null; static isLoading = !1; static init() { window.addEventListener("hashchange", () => this.navigate()), this.navigate() } static async navigate(t = null) { if (t = t || window.location.hash.slice(1) || "cut-planner", this.routes[t]) { if (!this.isLoading) { this.isLoading = !0, this.currentModule && this.currentModule.cleanup && this.currentModule.cleanup(), this.currentModule = null, window.currentPageModule = null; try { const e = this.routes[t], i = document.getElementById("page-container"), s = await fetch(e.file); if (!s.ok) throw new Error(`HTTP ${s.status}`); i.innerHTML = await s.text(); const n = e.file.replace(".html", ".css"); this.loadCSS(n).catch(() => { }); const a = document.createElement("script"); a.src = e.js, a.onload = () => { this.currentPage = t, this.currentModule = window.currentPageModule || {}, this.currentModule.init && this.currentModule.init(), this.updateNav(t), this.isLoading = !1 }, a.onerror = () => { i.innerHTML = `<div style="color: red; padding: 20px;">Error loading ${t}</div>`, this.isLoading = !1 }, document.body.appendChild(a) } catch (t) { document.getElementById("page-container").innerHTML = `<div style="color: red; padding: 20px;">Error: ${t.message}</div>`, this.isLoading = !1 } } } else window.location.hash = "#dashboard" } static loadCSS(t) { return new Promise((e, i) => { if (document.querySelector(`link[href="${t}"]`)) return void e(); const s = document.createElement("link"); s.rel = "stylesheet", s.href = t, s.onload = e, s.onerror = i, document.head.appendChild(s) }) } static updateNav(t) { document.querySelectorAll(".nav-item").forEach(e => { e.classList.toggle("active", e.getAttribute("href").slice(1) === t) }) } static go(t) { window.location.hash = "#" + t } } window.Router = Router, "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", () => { ThemeManager.init(), Router.init() }) : (ThemeManager.init(), Router.init(), setTimeout(() => AppState.checkForUpdates(), 2e3)), "serviceWorker" in navigator && navigator.serviceWorker.register("/sw.js").catch(() => { }); class GraphVisualizer { constructor(t, e = {}) { if (this.canvas = document.getElementById(t), this.series = new Map, this.seriesColors = ["#10b981", "#3b82f6", "#f59e0b", "#ef4444", "#8b5cf6", "#ec4899"], this.config = { title: e.title || "Graph", timeWindow: e.timeWindow || 3e5, maxPoints: e.maxPoints || 300, updateInterval: e.updateInterval || 1e3, yMin: e.yMin || 0, yMax: e.yMax || 100, autoScale: !1 !== e.autoScale, unit: e.unit || "%", showGrid: !1 !== e.showGrid, showLegend: !1 !== e.showLegend, ...e }, !this.canvas) return console.error(`[Graph] Canvas element '${t}' not found`), void (this.isDisabled = !0); this.ctx = this.canvas.getContext("2d"), this.width = this.canvas.width, this.height = this.canvas.height, this.colors = { bg: getComputedStyle(document.documentElement).getPropertyValue("--bg-primary") || "#ffffff", grid: getComputedStyle(document.documentElement).getPropertyValue("--border-color") || "#e5e7eb", text: getComputedStyle(document.documentElement).getPropertyValue("--text-primary") || "#000000", optimal: getComputedStyle(document.documentElement).getPropertyValue("--color-optimal") || "#10b981", normal: getComputedStyle(document.documentElement).getPropertyValue("--color-normal") || "#3b82f6", warning: getComputedStyle(document.documentElement).getPropertyValue("--color-warning") || "#f59e0b", critical: getComputedStyle(document.documentElement).getPropertyValue("--color-critical") || "#ef4444" }, this.seriesColors = [this.colors.optimal, this.colors.normal, this.colors.warning, this.colors.critical, "#8b5cf6", "#ec4899"], this.resizeObserver = new ResizeObserver(() => this.handleResize()), this.resizeObserver.observe(this.canvas), this.animationFrame = null, this.lastDrawTime = 0, this.draw() } handleResize() { const t = this.canvas.parentElement.getBoundingClientRect(); this.canvas.width = t.width, this.canvas.height = t.height, this.width = this.canvas.width, this.height = this.canvas.height, this.draw() } addSeries(t, e = null) { if (!this.series.has(t)) { const i = this.series.size % this.seriesColors.length; this.series.set(t, { data: [], color: e || this.seriesColors[i], visible: !0 }) } } addDataPoint(t, e, i = null) { this.series.has(t) || this.addSeries(t); const s = this.series.get(t), n = i || Date.now(); s.data.push({ time: n, value: e }); const a = n - this.config.timeWindow; s.data = s.data.filter(t => t.time >= a), s.data.length > this.config.maxPoints && (s.data = s.data.slice(-this.config.maxPoints)), this.draw() } toggleSeries(t, e = null) { if (this.series.has(t)) { const i = this.series.get(t); i.visible = null !== e ? e : !i.visible, this.draw() } } clear() { this.series.forEach(t => { t.data = [] }), this.draw() } clearSeries(t) { this.series.has(t) && (this.series.get(t).data = [], this.draw()) } getMinMax() { let t = 1 / 0, e = -1 / 0; this.series.forEach(i => { i.visible && i.data.forEach(i => { t = Math.min(t, i.value), e = Math.max(e, i.value) }) }), t = Math.min(t, this.config.yMin), e = Math.max(e, this.config.yMax), t === 1 / 0 && (t = 0), e === -1 / 0 && (e = 100); const i = .1 * (e - t); return { min: Math.max(0, t - i), max: e + i } } valueToCanvasY(t, e, i) { const s = this.height - 60 - 60; return 60 + s - (t - e) / (i - e) * s } timeToCanvasX(t, e, i) { return 50 + (t - e) / (i - e) * (this.width - 50 - 20) } draw() { if (this.isDisabled || !this.canvas || !this.ctx) return; this.ctx.fillStyle = this.colors.bg, this.ctx.fillRect(0, 0, this.width, this.height); let t = Date.now() - this.config.timeWindow, e = Date.now(); this.drawTitle(), this.config.showGrid && this.drawGrid(t, e); const { min: i, max: s } = this.getMinMax(); this.drawYAxisLabels(i, s), this.drawXAxisLabels(t, e), this.drawAxes(), this.drawDataSeries(t, e, i, s), this.config.showLegend && this.drawLegend(i, s) } drawTitle() { this.ctx.fillStyle = this.colors.text, this.ctx.font = "bold 14px Arial", this.ctx.textAlign = "left", this.ctx.fillText(this.config.title, 10, 20) } drawGrid(t, e) { this.ctx.strokeStyle = this.colors.grid, this.ctx.lineWidth = 1, this.ctx.globalAlpha = .3; let i = 6e4; this.config.timeWindow > 3e5 && (i = 18e4), this.config.timeWindow > 9e5 && (i = 3e5), this.config.timeWindow > 18e5 && (i = 6e5); for (let s = 0; s < this.config.timeWindow; s += i) { const i = e - s, n = this.timeToCanvasX(i, t, e); this.ctx.beginPath(), this.ctx.moveTo(n, 50), this.ctx.lineTo(n, this.height - 60), this.ctx.stroke() } const { min: s, max: n } = this.getMinMax(), a = this.getGridStep(s, n); for (let t = Math.ceil(s / a) * a; t <= n; t += a) { const e = this.valueToCanvasY(t, s, n); this.ctx.beginPath(), this.ctx.moveTo(50, e), this.ctx.lineTo(this.width - 20, e), this.ctx.stroke() } this.ctx.globalAlpha = 1 } getGridStep(t, e) { const i = e - t; if (0 === i) return 1; const s = i / 6, n = Math.pow(10, Math.floor(Math.log10(s))), a = s / n; let o; return o = a < 1.5 ? 1 * n : a < 3.5 ? 2 * n : a < 7.5 ? 5 * n : 10 * n, o } drawYAxisLabels(t, e) { this.ctx.fillStyle = this.colors.text, this.ctx.font = "11px Arial", this.ctx.textAlign = "right", this.ctx.globalAlpha = .7; const i = this.getGridStep(t, e); for (let s = Math.ceil(t / i) * i; s <= e; s += i) { const i = this.valueToCanvasY(s, t, e); this.ctx.fillText(s.toFixed(0) + this.config.unit, 45, i + 4) } this.ctx.globalAlpha = 1 } drawXAxisLabels(t, e) { this.ctx.fillStyle = this.colors.text, this.ctx.font = "11px Arial", this.ctx.textAlign = "center", this.ctx.globalAlpha = .7; let i = 6e4; this.config.timeWindow > 3e5 && (i = 18e4), this.config.timeWindow > 9e5 && (i = 3e5), this.config.timeWindow > 18e5 && (i = 6e5); for (let s = 0; s <= this.config.timeWindow; s += i) { const i = e - s, n = this.timeToCanvasX(i, t, e), a = Math.round(s / 1e3); let o = ""; o = 0 === a ? "Now" : a < 60 ? a + "s ago" : a < 3600 ? Math.round(a / 60) + "m ago" : Math.round(a / 3600) + "h ago", this.ctx.fillText(o, n, this.height - 42) } this.ctx.globalAlpha = 1 } drawAxes() { this.ctx.strokeStyle = this.colors.text, this.ctx.lineWidth = 2, this.ctx.beginPath(), this.ctx.moveTo(50, 50), this.ctx.lineTo(50, this.height - 60), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(50, this.height - 60), this.ctx.lineTo(this.width - 20, this.height - 60), this.ctx.stroke() } drawDataSeries(t, e, i, s) { const { min: n, max: a } = this.getMinMax(); this.series.forEach((i, s) => { if (i.visible && 0 !== i.data.length) { this.ctx.strokeStyle = i.color, this.ctx.lineWidth = 2, this.ctx.globalAlpha = .8, this.ctx.beginPath(); for (let s = 0; s < i.data.length; s++) { const o = i.data[s], r = this.timeToCanvasX(o.time, t, e), c = this.valueToCanvasY(o.value, n, a); 0 === s ? this.ctx.moveTo(r, c) : this.ctx.lineTo(r, c) } this.ctx.stroke(), this.ctx.fillStyle = i.color, i.data.forEach(i => { const s = this.timeToCanvasX(i.time, t, e), o = this.valueToCanvasY(i.value, n, a); this.ctx.fillRect(s - 2, o - 2, 4, 4) }), this.ctx.globalAlpha = 1 } }) } drawLegend(t, e) { const i = this.height - 30; let s = 0; this.series.forEach((t, e) => { if (!t.visible) return; const n = 60 + 120 * s, a = i; this.ctx.fillStyle = t.color, this.ctx.globalAlpha = .8, this.ctx.fillRect(n, a, 10, 10), this.ctx.fillStyle = this.colors.text, this.ctx.globalAlpha = 1, this.ctx.font = "11px Arial", this.ctx.textAlign = "left", this.ctx.fillText(e, n + 15, a + 9), s++ }) } destroy() { this.resizeObserver && this.resizeObserver.disconnect(), this.animationFrame && cancelAnimationFrame(this.animationFrame) } getStats(t) { if (!this.series.has(t)) return null; const e = this.series.get(t).data; if (0 === e.length) return null; const i = e.map(t => t.value); return { avg: i.reduce((t, e) => t + e, 0) / i.length, min: Math.min(...i), max: Math.max(...i), current: e[e.length - 1].value, count: i.length } } exportData() { let t = "Time," + Array.from(this.series.keys()).join(",") + "\n"; if (0 === this.series.size) return t; const e = new Map; this.series.forEach((t, i) => { t.data.forEach(t => { e.has(t.time) || e.set(t.time, {}), e.get(t.time)[i] = t.value }) }); const i = Array.from(e.keys()).sort((t, e) => t - e), s = Array.from(this.series.keys()); return i.forEach(i => { const n = [new Date(i).toISOString()], a = e.get(i); s.forEach(t => { n.push(a[t] || "") }), t += n.join(",") + "\n" }), t } } class PositionVisualizer { constructor(t, e = {}) { this.canvas = document.getElementById(t), this.canvas ? (this.ctx = this.canvas.getContext("2d"), this.width = this.canvas.width, this.height = this.canvas.height, this.config = { x_min: e.x_min || -100, x_max: e.x_max || 500, y_min: e.y_min || -100, y_max: e.y_max || 500, z_min: e.z_min || 0, z_max: e.z_max || 100, showGrid: !1 !== e.showGrid, showLimits: !1 !== e.showLimits, showTrail: !1 !== e.showTrail, ...e }, this.position = { x: this.config.x_min, y: this.config.y_min, z: this.config.z_min, a: 0 }, this.trail = [], this.maxTrailLength = 100, this.colors = { bg: getComputedStyle(document.documentElement).getPropertyValue("--bg-primary") || "#ffffff", grid: getComputedStyle(document.documentElement).getPropertyValue("--border-color") || "#e5e7eb", limit: getComputedStyle(document.documentElement).getPropertyValue("--color-warning") || "#f59e0b", position: getComputedStyle(document.documentElement).getPropertyValue("--color-optimal") || "#10b981", trail: getComputedStyle(document.documentElement).getPropertyValue("--color-normal") || "#3b82f6", text: getComputedStyle(document.documentElement).getPropertyValue("--text-primary") || "#000000" }, this.padding = 60, this.resizeObserver = new ResizeObserver(() => this.handleResize()), this.resizeObserver.observe(this.canvas), this.draw()) : console.error(`[PosViz] Canvas element '${t}' not found`) } handleResize() { const t = this.canvas.parentElement.getBoundingClientRect(); this.canvas.width = t.width, this.canvas.height = t.height, this.width = this.canvas.width, this.height = this.canvas.height, this.draw() } updatePosition(t, e, i, s) { this.position.x = t, this.position.y = e, this.position.z = i, this.position.a = s || 0, this.config.showTrail && (this.trail.push({ x: t, y: e, z: i }), this.trail.length > this.maxTrailLength && this.trail.shift()), this.draw() } toCanvasX(t) { const e = this.config.x_max - this.config.x_min, i = (t - this.config.x_min) / e; return this.padding + i * (this.width - 2 * this.padding) } toCanvasY(t) { const e = this.config.y_max - this.config.y_min, i = (t - this.config.y_min) / e; return this.height - this.padding - i * (this.height - 2 * this.padding) } draw() { this.ctx.fillStyle = this.colors.bg, this.ctx.fillRect(0, 0, this.width, this.height), this.config.showGrid && this.drawGrid(), this.config.showLimits && this.drawLimits(), this.config.showTrail && this.trail.length > 1 && this.drawTrail(), this.drawLabels(), this.drawPosition(), this.drawInfoBox() } drawGrid() { this.ctx.strokeStyle = this.colors.grid, this.ctx.lineWidth = 1, this.ctx.globalAlpha = .3; const t = 50; this.config.x_max, this.config.x_min, this.config.y_max, this.config.y_min; let e = Math.ceil(this.config.x_min / t) * t; for (; e <= this.config.x_max;) { const i = this.toCanvasX(e); this.ctx.beginPath(), this.ctx.moveTo(i, this.padding), this.ctx.lineTo(i, this.height - this.padding), this.ctx.stroke(), e += t } let i = Math.ceil(this.config.y_min / t) * t; for (; i <= this.config.y_max;) { const e = this.toCanvasY(i); this.ctx.beginPath(), this.ctx.moveTo(this.padding, e), this.ctx.lineTo(this.width - this.padding, e), this.ctx.stroke(), i += t } this.ctx.globalAlpha = 1 } drawLimits() { this.ctx.strokeStyle = this.colors.limit, this.ctx.lineWidth = 2, this.ctx.setLineDash([5, 5]), this.ctx.globalAlpha = .5; const t = this.toCanvasX(this.config.x_min), e = this.toCanvasY(this.config.y_max), i = this.toCanvasX(this.config.x_max), s = this.toCanvasY(this.config.y_min); this.ctx.strokeRect(t, e, i - t, s - e), this.ctx.setLineDash([]), this.ctx.globalAlpha = 1 } drawTrail() { this.ctx.strokeStyle = this.colors.trail, this.ctx.lineWidth = 1.5, this.ctx.globalAlpha = .6, this.ctx.beginPath(); for (let t = 0; t < this.trail.length; t++) { const e = this.trail[t], i = this.toCanvasX(e.x), s = this.toCanvasY(e.y); 0 === t ? this.ctx.moveTo(i, s) : this.ctx.lineTo(i, s) } this.ctx.stroke(), this.ctx.globalAlpha = 1 } drawLabels() { this.ctx.fillStyle = this.colors.text, this.ctx.font = "12px Arial", this.ctx.textAlign = "center", this.ctx.globalAlpha = .5; let t = 100 * Math.ceil(this.config.x_min / 100); for (; t <= this.config.x_max;) { const e = this.toCanvasX(t); this.ctx.fillText(t + "mm", e, this.height - 20), t += 100 } this.ctx.textAlign = "right"; let e = 100 * Math.ceil(this.config.y_min / 100); for (; e <= this.config.y_max;) { const t = this.toCanvasY(e); this.ctx.fillText(e + "mm", this.padding - 8, t + 4), e += 100 } this.ctx.globalAlpha = 1 } drawPosition() { const t = this.toCanvasX(this.position.x), e = this.toCanvasY(this.position.y); this.ctx.fillStyle = this.colors.position, this.ctx.beginPath(), this.ctx.arc(t, e, 8, 0, 2 * Math.PI), this.ctx.fill(), this.ctx.strokeStyle = this.colors.position, this.ctx.lineWidth = 2, this.ctx.globalAlpha = .7, this.ctx.beginPath(), this.ctx.moveTo(t - 15, e), this.ctx.lineTo(t + 15, e), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(t, e - 15), this.ctx.lineTo(t, e + 15), this.ctx.stroke(), this.ctx.globalAlpha = 1 } drawInfoBox() { const t = this.width - 150 - 10; this.ctx.fillStyle = "rgba(0, 0, 0, 0.5)", this.ctx.fillRect(t, 10, 150, 90), this.ctx.strokeStyle = this.colors.text, this.ctx.lineWidth = 1, this.ctx.globalAlpha = .5, this.ctx.strokeRect(t, 10, 150, 90), this.ctx.globalAlpha = 1, this.ctx.fillStyle = this.colors.position, this.ctx.font = "bold 12px Arial", this.ctx.textAlign = "left"; let e = 30; this.ctx.fillStyle = "#ffffff", this.ctx.fillText(`X: ${this.position.x.toFixed(1)} mm`, t + 10, e), e += 18, this.ctx.fillText(`Y: ${this.position.y.toFixed(1)} mm`, t + 10, e), e += 18, this.ctx.fillText(`Z: ${this.position.z.toFixed(1)} mm`, t + 10, e), e += 18, this.ctx.fillText(`A: ${this.position.a.toFixed(1)}Â°`, t + 10, e) } clearTrail() { this.trail = [], this.draw() } destroy() { this.resizeObserver && this.resizeObserver.disconnect() } } class SharedWebSocket { static ws = null; static isConnected = !1; static reconnectAttempts = 0; static maxReconnectAttempts = 10; static baseReconnectDelay = 1e3; static maxReconnectDelay = 3e4; static currentReconnectDelay = 1e3; static reconnectTimer = null; static listeners = []; static packetsSent = 0; static packetsReceived = 0; static dataReceivedBytes = 0; static latency = 0; static lastPingTime = 0; static pingInterval = null; static connect() { if (this.reconnectTimer && (clearTimeout(this.reconnectTimer), this.reconnectTimer = null), this.ws && this.ws.readyState === WebSocket.OPEN) return this.ws; if (this.ws) { try { this.ws.close() } catch (t) { } this.ws = null } try { const t = `${"https:" === window.location.protocol ? "wss:" : "ws:"}//${window.location.hostname}:${window.location.port}/ws`; return console.log("[WS] Connecting to", t), this.ws = new WebSocket(t), this.ws.onopen = () => { this.isConnected = !0, this.reconnectAttempts = 0, this.currentReconnectDelay = this.baseReconnectDelay, console.log("[WS] Connected"), this.broadcast("ws-connected"), void 0 !== AlertManager && this.reconnectAttempts > 0 && AlertManager.add("WebSocket reconnected", "success", 2e3), this.startLatencyTracking() }, this.ws.onmessage = t => { this.packetsReceived++, t.data && (this.dataReceivedBytes += t.data.length); try { const e = JSON.parse(t.data); if ("pong" === e.type) return void (this.lastPingTime > 0 && (this.latency = Date.now() - this.lastPingTime)); this.broadcast("telemetry", e) } catch (t) { console.error("[WS] Parse error:", t) } }, this.ws.onerror = t => { console.error("[WS] Error:", t), this.broadcast("ws-error", t) }, this.ws.onclose = t => { this.isConnected = !1, console.log("[WS] Disconnected (code:", t.code, ")"), this.broadcast("ws-disconnected"), this.scheduleReconnect() }, this.ws } catch (t) { return console.error("[WS] Connection failed:", t), this.scheduleReconnect(), null } } static scheduleReconnect() { if (this.reconnectAttempts >= this.maxReconnectAttempts) return console.error("[WS] Max reconnection attempts reached"), this.broadcast("ws-failed"), void (void 0 !== AlertManager && AlertManager.add("WebSocket connection failed. Refresh page to retry.", "error", 1e4)); this.reconnectAttempts++, this.currentReconnectDelay = Math.min(this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay), console.log(`[WS] Reconnecting in ${this.currentReconnectDelay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`), this.broadcast("ws-reconnecting", { attempt: this.reconnectAttempts, maxAttempts: this.maxReconnectAttempts, delay: this.currentReconnectDelay }), this.reconnectTimer = setTimeout(() => { this.reconnectTimer = null, this.connect() }, this.currentReconnectDelay) } static forceReconnect() { if (console.log("[WS] Force reconnect requested"), this.reconnectAttempts = 0, this.currentReconnectDelay = this.baseReconnectDelay, this.reconnectTimer && (clearTimeout(this.reconnectTimer), this.reconnectTimer = null), this.ws) { try { this.ws.close() } catch (t) { } this.ws = null } this.connect() } static send(t) { return this.ws && this.isConnected && this.ws.readyState === WebSocket.OPEN ? (this.ws.send(JSON.stringify(t)), this.packetsSent++, !0) : (console.warn("[WS] Not connected, message not sent"), !1) } static subscribe(t) { return this.listeners.push(t), () => { this.listeners = this.listeners.filter(e => e !== t) } } static broadcast(t, e = null) { window.dispatchEvent(new CustomEvent(t, { detail: e })) } static disconnect() { this.reconnectTimer && (clearTimeout(this.reconnectTimer), this.reconnectTimer = null), this.ws && (this.ws.close(), this.ws = null), this.isConnected = !1, this.stopLatencyTracking() } static startLatencyTracking() { this.stopLatencyTracking(), this.pingInterval = setInterval(() => { this.isConnected && this.ws.readyState === WebSocket.OPEN && this.ping() }, 5e3) } static ping() { this.isConnected && this.ws.readyState === WebSocket.OPEN && (this.lastPingTime = Date.now(), this.ws.send(JSON.stringify({ type: "ping" }))) } static stopLatencyTracking() { this.pingInterval && (clearInterval(this.pingInterval), this.pingInterval = null) } static getStatus() { return { connected: this.isConnected, reconnecting: null !== this.reconnectTimer, attempts: this.reconnectAttempts, maxAttempts: this.maxReconnectAttempts, nextRetryMs: this.currentReconnectDelay } } } "file:" !== window.location.protocol && ("loading" === document.readyState ? document.addEventListener("DOMContentLoaded", () => setTimeout(() => SharedWebSocket.connect(), 1000)) : setTimeout(() => SharedWebSocket.connect(), 1000)); const Toast = { container: null, queue: [], maxToasts: 5, init() { this.container || (this.container = document.createElement("div"), this.container.id = "toast-container", this.container.className = "toast-container", document.body.appendChild(this.container), console.log("[Toast] Notification system initialized"), window.addEventListener("alert-added", t => { const e = t.detail, i = "critical" === e.type ? "error" : e.type, s = null !== e.duration ? e.duration : 3e3; this.show(e.message, i, s) })) }, show(t, e = "info", i = 3e3) { if (this.container || this.init(), "error" !== e) { this.container.querySelectorAll(".toast").forEach(t => { t.classList.contains("toast-error") || this.remove(t) }) } const s = document.createElement("div"); s.className = `toast toast-${e}`; const n = { success: "âœ“", error: "âœ•", warning: "âš ", info: "â„¹" }, a = n[e] || n.info; s.innerHTML = `\n            <div class="toast-icon">${a}</div>\n            <div class="toast-message">${Utils.escapeHtml(t)}</div>\n            <button class="toast-close" aria-label="Close">OK</button>\n        `; return s.querySelector(".toast-close").addEventListener("click", () => this.remove(s)), this.container.appendChild(s), requestAnimationFrame(() => { s.classList.add("toast-show") }), i > 0 && setTimeout(() => this.remove(s), i), this.limitToasts(), s }, success(t, e = 3e3) { return this.show(t, "success", e) }, error(t, e = 5e3) { return this.show(t, "error", e) }, warning(t, e = 4e3) { return this.show(t, "warning", e) }, info(t, e = 3e3) { return this.show(t, "info", e) }, remove(t) { t && t.parentNode && (t.classList.remove("toast-show"), t.classList.add("toast-hide"), setTimeout(() => { t.parentNode && t.parentNode.removeChild(t) }, 300)) }, clear() { if (!this.container) return; this.container.querySelectorAll(".toast").forEach(t => this.remove(t)) }, limitToasts() { if (!this.container) return; const t = this.container.querySelectorAll(".toast"); if (t.length > this.maxToasts) { Array.from(t).slice(0, t.length - this.maxToasts).forEach(t => this.remove(t)) } } }; "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", () => Toast.init()) : Toast.init(), window.Toast = Toast; class AlertManager { static alerts = []; static maxAlerts = 100; static listeners = []; static add(t, e = "info", i = null) { const s = { id: Date.now(), message: t, type: e, timestamp: new Date, duration: i }; return this.alerts.unshift(s), this.alerts.length > this.maxAlerts && this.alerts.pop(), this.notifyListeners("alert-added", s), i && setTimeout(() => this.remove(s.id), i), "critical" === e && this.playSound("critical"), s.id } static remove(t) { const e = this.alerts.findIndex(e => e.id === t); if (-1 !== e) { const t = this.alerts.splice(e, 1)[0]; this.notifyListeners("alert-removed", t) } } static clear() { this.alerts = [], this.notifyListeners("alerts-cleared") } static getAll() { return this.alerts } static subscribe(t) { return this.listeners.push(t), () => { this.listeners = this.listeners.filter(e => e !== t) } } static notifyListeners(t, e) { window.dispatchEvent(new CustomEvent(t, { detail: e })) } static playSound(t) { try { const e = new (window.AudioContext || window.webkitAudioContext), i = e.createOscillator(), s = e.createGain(); i.connect(s), s.connect(e.destination); const n = "critical" === t ? 1e3 : 500, a = "critical" === t ? .2 : .1; i.frequency.value = n, s.gain.setValueAtTime(.3, e.currentTime), s.gain.exponentialRampToValueAtTime(.01, e.currentTime + a), i.start(e.currentTime), i.stop(e.currentTime + a) } catch (t) { console.log("[ALERT] Cannot play sound:", t.message) } } } window.addEventListener("state-changed", t => { const e = t.detail; e.axis && ["x", "y", "z"].forEach(t => { const i = e.axis[t]; i && i.stalled && AlertManager.add(`Axis ${t.toUpperCase()} STALLED`, "critical", null), i && i.quality < 25 && AlertManager.add(`Axis ${t.toUpperCase()} quality critical: ${i.quality}%`, "warning", 5e3) }), e.vfd && 0 !== e.vfd.fault_code && AlertManager.add(`VFD Fault Code: 0x${e.vfd.fault_code.toString(16).toUpperCase()}`, "warning", 1e4), e.vfd && e.vfd.thermal_percent > 85 && AlertManager.add(`VFD Thermal Warning: ${e.vfd.thermal_percent}%`, "warning", 5e3) });
