window.NetworkModule = { latencyHistory: [], maxHistoryLength: 100, reconnectCount: 0, connectionStartTime: Date.now(), stats: { packetsSent: 0, packetsReceived: 0, errors: 0, dataReceived: 0 }, init() { console.log("[Network] Initializing"), this.loadWiFiConfig(), this.updateNetworkStatus(), this.setupEventListeners(), this.startLatencyMonitoring(), window.addEventListener("state-changed", () => this.onStateChanged()) }, setupEventListeners() { const t = document.getElementById("ap-enabled"); t && t.addEventListener("change", t => { const e = document.getElementById("ap-settings-fields"); e && (e.style.display = t.target.checked ? "block" : "none") }); const btEth = document.getElementById("save-eth-btn"); btEth && btEth.addEventListener("click", () => this.saveEthConfig()); const e = document.getElementById("save-station-btn"); e && e.addEventListener("click", () => this.saveStationConfig()); const n = document.getElementById("save-ap-btn"); n && n.addEventListener("click", () => this.saveAPConfig()); const o = document.getElementById("ping-btn"); o && o.addEventListener("click", () => this.sendPing()); const s = document.getElementById("reconnect-btn"); s && s.addEventListener("click", () => this.reconnectDevice()); const a = document.getElementById("toggle-station-pass"); a ? (console.log("[Network] Added station toggle listener"), a.addEventListener("click", t => { t.preventDefault(), console.log("[Network] Station toggle clicked"), this.togglePass("station-pass") })) : console.warn("[Network] Station toggle button not found"); const i = document.getElementById("toggle-ap-pass"); i ? (console.log("[Network] Added AP toggle listener"), i.addEventListener("click", t => { t.preventDefault(), console.log("[Network] AP toggle clicked"), this.togglePass("ap-pass") })) : console.warn("[Network] AP toggle button not found"); const c = document.getElementById("network-test-btn"); c && c.addEventListener("click", () => this.runDiagnostics()); const d = document.getElementById("close-diagnostics"); d && d.addEventListener("click", () => this.closeDiagnostics()); const r = document.getElementById("export-diagnostics"); r && r.addEventListener("click", () => this.exportDiagnostics()) }, updateNetworkStatus() { this.updateWiFiStatus(), this.updateUptimeInfo(), setInterval(() => this.updateWiFiStatus(), 5e3), setInterval(() => this.updateUptimeInfo(), 1e3) }, updateWiFiStatus() { fetch("/api/network/status").then(t => t.json()).then(t => { const e = t.wifi_connected ? "Connected" : "Disconnected", n = t.wifi_ssid || "--", o = t.wifi_rssi || -100, s = t.signal_quality || 0, a = document.getElementById("wifi-status"), i = document.getElementById("wifi-ssid"), c = document.getElementById("signal-dbm"); a && (a.textContent = e, a.style.color = t.wifi_connected ? "var(--color-optimal)" : "var(--color-critical)"), i && (i.textContent = n), c && (c.textContent = o + " dBm"); const d = document.getElementById("signal-bar"); d && (d.style.width = s + "%"); const r = s > 75 ? "Excellent" : s > 50 ? "Good" : s > 25 ? "Fair" : "Poor", l = document.getElementById("signal-quality"); l && (l.textContent = r), Utils.setText("signal-quality", r); const g = document.getElementById("signal-bar"); g && (g.style.background = s > 75 ? "var(--color-optimal)" : s > 50 ? "var(--color-normal)" : s > 25 ? "var(--color-warning)" : "var(--color-critical)"), Utils.setText("ip-address", t.wifi_ip || "--"), Utils.setText("gateway-address", t.wifi_gateway || "--"), Utils.setText("mac-address", t.wifi_mac || "--"); const u = t.eth_connected, m = document.getElementById("eth-status"); if (m && (m.textContent = u ? "Connected" : "Disconnected", m.style.color = u ? "var(--color-optimal)" : "var(--color-critical)"), Utils.setText("eth-speed", u ? t.eth_speed + " Mbps" : "--"), Utils.setText("eth-duplex", u ? t.eth_duplex ? "Full" : "Half" : "--"), Utils.setText("eth-ip", t.eth_ip || "--"), Utils.setText("eth-gateway", t.eth_gateway || "--"), Utils.setText("eth-mac", t.eth_mac || "--"), t.uptime_ms) { const e = Math.floor(t.uptime_ms / 1e3), n = Math.floor(e / 3600), o = Math.floor(e % 3600 / 60), s = document.getElementById("device-uptime"); s && (s.textContent = n + " h " + o + " m") } }).catch(t => console.error("[Network] Status fetch failed:", t)) }, updateLatency() { const t = SharedWebSocket.latency || 0; if (t > 0) { this.latencyHistory.push(t), this.latencyHistory.length > this.maxHistoryLength && this.latencyHistory.shift(); const e = document.getElementById("latency-ms"); e && (e.textContent = t + " ms"); const n = Math.min(...this.latencyHistory), o = Math.max(...this.latencyHistory), s = (Math.round(this.latencyHistory.reduce((t, e) => t + e, 0) / this.latencyHistory.length), document.getElementById("latency-min")), a = document.getElementById("latency-max"); document.getElementById("latency-avg"); s && (s.textContent = n + " ms"), a && (a.textContent = o + " ms") } }, updateModbusStatus() { const t = AppState.data, e = !0 === t.vfd?.connected, n = e ? "Connected" : "Disconnected", o = document.getElementById("modbus-status"); o && (o.textContent = n, o.style.color = e ? "var(--color-optimal)" : "var(--color-critical)"); const s = document.getElementById("vfd-na"); s && (s.style.display = e ? "none" : "inline"); const a = document.getElementById("vfd-latency"); a && (a.textContent = "-- ms"); const i = document.getElementById("modbus-last-read"); i && (i.textContent = (new Date).toLocaleTimeString()) }, updateUptimeInfo() { const t = Date.now() - this.connectionStartTime, e = Math.floor(t / 6e4), n = document.getElementById("connection-duration"), o = document.getElementById("reconnect-count"); n && (n.textContent = e + " m"), o && (o.textContent = this.reconnectCount); const s = SharedWebSocket.packetsSent || 0, a = SharedWebSocket.packetsReceived || 0, i = SharedWebSocket.dataReceivedBytes || 0, c = document.getElementById("packets-sent"), d = document.getElementById("packets-received"), r = document.getElementById("data-received"); c && (c.textContent = s), d && (d.textContent = a), r && (r.textContent = (i / 1024).toFixed(1) + " KB") }, startLatencyMonitoring() { setInterval(() => { this.updateLatency(), this.updateModbusStatus() }, 2e3) }, sendPing() { AlertManager.add("Pinging device via WebSocket...", "info"), SharedWebSocket.ping() }, reconnectDevice() { AlertManager.add("Reconnecting WiFi...", "info"), fetch("/api/network/reconnect", { method: "POST" }).then(t => t.json()).then(t => { t.success ? (AlertManager.add("WiFi reconnection triggered", "success", 2e3), this.reconnectCount++) : AlertManager.add("Failed to trigger reconnect", "error") }).catch(t => AlertManager.add("Reconnect API failed", "error")) }, runDiagnostics() { const t = document.getElementById("network-diagnostics-modal"); t && (t.style.display = "flex"); const e = document.getElementById("diagnostics-output"); e.textContent = "Running diagnostics...\n\n", fetch("/api/network/status").then(t => t.json()).then(t => { const n = Math.floor((t.uptime_ms || 0) / 1e3), o = Math.floor(n / 3600), s = Math.floor(n % 3600 / 60), a = t.signal_quality > 75 ? "Excellent" : t.signal_quality > 50 ? "Good" : t.signal_quality > 25 ? "Fair" : "Poor", i = ["WiFi Status: " + (t.wifi_connected ? "Connected" : "Disconnected"), `SSID: ${t.wifi_ssid || "N/A"}`, `WiFi Signal: ${t.wifi_rssi} dBm (${a})`, `WiFi IP: ${t.wifi_ip || "N/A"}`, `WiFi MAC: ${t.wifi_mac || "N/A"}`, `Gateway: ${t.wifi_gateway || "N/A"}`, `DNS: ${t.wifi_dns || "N/A"}`, `Signal Quality: ${t.signal_quality}%`, "", "Ethernet Status: " + (t.eth_connected ? "Connected" : "Disconnected"), `Ethernet IP: ${t.eth_ip || "N/A"}`, `Ethernet MAC: ${t.eth_mac || "N/A"}`, "Link Speed: " + (t.eth_connected ? t.eth_speed + " Mbps" : "N/A"), "Duplex: " + (t.eth_connected ? t.eth_duplex ? "Full" : "Half" : "N/A"), "", `Uptime: ${o}h ${s}m`, "", t.wifi_connected || t.eth_connected ? "✓ Network operational" : "✗ Network disconnected"]; let c = 0; const d = setInterval(() => { c < i.length ? (e.textContent += i[c] + "\n", e.scrollTop = e.scrollHeight, c++) : clearInterval(d) }, 150) }).catch(t => { e.textContent += "Error fetching network status: " + t.message + "\n" }) }, closeDiagnostics() { const t = document.getElementById("network-diagnostics-modal"); t && (t.style.display = "none") }, exportDiagnostics() { const t = document.getElementById("diagnostics-output"), e = t ? t.innerText : "No diagnostics data found.", n = `Network Diagnostics Report\nGenerated: ${(new Date).toLocaleString()}\n\n${e}\n`, o = new Blob([n], { type: "text/plain" }), s = window.URL.createObjectURL(o), a = document.createElement("a"); a.href = s, a.download = `network-diagnostics-${Date.now()}.txt`, a.click(), window.URL.revokeObjectURL(s), AlertManager.add("Diagnostics exported", "success", 2e3) }, loadWiFiConfig() { console.log("[Network] Loading WiFi configuration"), fetch("/api/config/get?category=5").then(t => t.json()).then(t => { if (t.error) console.error("[Network] Config load error:", t), this.setStatus("station", "Error: " + t.error, "error"), this.setStatus("ap", "Error: " + t.error, "error"), AlertManager.add("Failed to load WiFi config: " + t.error, "error"); else { const e = t; Utils.setValue("station-ssid", e.wifi_ssid || ""), Utils.setValue("station-pass", e.wifi_pass || ""), Utils.setValue("ap-ssid", e.wifi_ap_ssid || ""), Utils.setValue("ap-pass", e.wifi_ap_pass || ""); const ethEn = document.getElementById("eth-enabled"); if (ethEn) ethEn.checked = !!e.eth_en; const n = document.getElementById("ap-enabled"); if (n) { n.checked = !!e.wifi_ap_en; const t = document.getElementById("ap-settings-fields"); t && (t.style.display = n.checked ? "block" : "none") } this.setStatus("station", "", ""), this.setStatus("ap", "", "") } }).catch(t => { console.error("[Network] Failed to load WiFi config:", t), this.setStatus("station", "Load failed: " + t.message, "error"), this.setStatus("ap", "Load failed: " + t.message, "error"), AlertManager.add("Network error loading config", "error") }) }, async saveEthConfig() { const t = document.getElementById("eth-enabled").checked ? 1 : 0; try { await this.setConfig("eth_en", t), AlertManager.add("Ethernet settings saved. Reboot required.", "success") } catch (t) { AlertManager.add("Failed to save Ethernet settings", "error") } }, async saveStationConfig() { const t = document.getElementById("station-ssid").value, e = document.getElementById("station-pass").value; if (t) { this.setStatus("station", "Saving...", ""); try { await this.setConfig("wifi_ssid", t), e && await this.setConfig("wifi_pass", e), AlertManager.add("Station settings saved. Reconnecting...", "success"), this.setStatus("station", "Saved", "success") } catch (t) { console.error("[Network] Save station failed:", t), AlertManager.add("Failed to save settings", "error"), this.setStatus("station", "Error", "error") } } else AlertManager.add("SSID is required", "error") }, async saveAPConfig() { const t = document.getElementById("ap-enabled").checked ? 1 : 0, e = document.getElementById("ap-ssid").value, n = document.getElementById("ap-pass").value; if (!t || e) if (t && n && n.length < 8) AlertManager.add("AP Password must be at least 8 chars", "error"); else { this.setStatus("ap", "Saving...", ""); try { await this.setConfig("wifi_ap_en", t), t && (await this.setConfig("wifi_ap_ssid", e), n && await this.setConfig("wifi_ap_pass", n)), AlertManager.add("AP settings saved. Reboot required.", "success"), this.setStatus("ap", "Saved", "success") } catch (t) { console.error("[Network] Save AP failed:", t), AlertManager.add("Failed to save AP settings", "error"), this.setStatus("ap", "Error", "error") } } else AlertManager.add("AP SSID is required when enabled", "error") }, setConfig: (t, e) => fetch("/api/config/set", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ category: 5, key: t, value: e }) }).then(t => t.json()).then(t => { if (!t.success) throw new Error(t.error || "Set failed"); return t }), togglePass(t) { const e = document.getElementById(t); e && (e.type = "password" === e.type ? "text" : "password") }, setStatus(t, e, n) { const o = document.getElementById(`${t}-config-status`); o && (o.textContent = e, o.className = "card-status " + (n || "")) }, onStateChanged() { }, cleanup() { console.log("[Network] Cleaning up") } }, window.currentPageModule = NetworkModule;