/**
 * Cut Planner - G-code generation for operator-friendly cutting jobs
 */

// Guard against re-declaration when Router reloads the script
if (typeof window.CutPlanner === 'undefined') {
    window.CutPlanner = {
        safeZ: 0,           // Captured at page load from current Z position
        currentJobType: null,
        generatedGcode: '',

        init() {
            console.log('[CutPlanner] Initialization V1.2 (Blade Thickness Fix)');
            this.captureSafeZ();
        },

        /**
         * Capture safe Z from current telemetry position
         */
        captureSafeZ() {
            if (typeof AppState !== 'undefined' && AppState.data && AppState.data.motion) {
                this.safeZ = AppState.data.motion.position?.z || 0;
            } else {
                fetch('/api/status')
                    .then(r => r.json())
                    .then(data => {
                        this.safeZ = (data.motion?.position?.z !== undefined) ?
                            data.motion.position.z : (data.z_pos || 0);
                    })
                    .catch(() => {
                        this.safeZ = 0;
                    });
            }
        },

        /**
         * Get form values for a job type
         */
        getParams(jobType) {
            switch (jobType) {
                case 'single':
                    return {
                        startY: parseFloat(document.getElementById('single-start-y').value) || 0,
                        endY: parseFloat(document.getElementById('single-end-y').value) || 0,
                        depth: parseFloat(document.getElementById('single-depth').value) || 0
                    };
                case 'linear-passes':
                    return {
                        startY: parseFloat(document.getElementById('passes-start-y').value) || 0,
                        endY: parseFloat(document.getElementById('passes-end-y').value) || 0,
                        totalDepth: parseFloat(document.getElementById('passes-total-depth').value) || 0,
                        forwardPass: parseFloat(document.getElementById('passes-forward').value) || 0,
                        backwardPass: parseFloat(document.getElementById('passes-backward').value) || 0
                    };
                case 'parallel':
                    const numPiecesP = parseInt(document.getElementById('parallel-num-pieces').value) || 1;
                    return {
                        startY: parseFloat(document.getElementById('parallel-start-y').value) || 0,
                        endY: parseFloat(document.getElementById('parallel-end-y').value) || 0,
                        depth: parseFloat(document.getElementById('parallel-depth').value) || 0,
                        numCuts: numPiecesP + 1,
                        numPieces: numPiecesP,
                        xStep: parseFloat(document.getElementById('parallel-x-step').value) || 0,
                        bladeThickness: parseFloat(document.getElementById('parallel-blade-thickness').value) || 0
                    };
                case 'parallel-passes':
                    const numPiecesPP = parseInt(document.getElementById('pp-num-pieces').value) || 1;
                    return {
                        startY: parseFloat(document.getElementById('pp-start-y').value) || 0,
                        endY: parseFloat(document.getElementById('pp-end-y').value) || 0,
                        totalDepth: parseFloat(document.getElementById('pp-total-depth').value) || 0,
                        forwardPass: parseFloat(document.getElementById('pp-forward').value) || 0,
                        backwardPass: parseFloat(document.getElementById('pp-backward').value) || 0,
                        numCuts: numPiecesPP + 1,
                        numPieces: numPiecesPP,
                        xStep: parseFloat(document.getElementById('pp-x-step').value) || 0,
                        bladeThickness: parseFloat(document.getElementById('pp-blade-thickness').value) || 0
                    };
                default:
                    return {};
            }
        },

        /**
         * Generate G-code for Single Linear Cut
         */
        generateSingle(p) {
            const cutDistance = p.endY - p.startY;
            const lines = [
                '; Single Linear Cut',
                '; Generated by Cut Planner',
                '; Job Origin (0) is starting saw position',
                '',
                'G91              ; Relative positioning',
                `G0 Y${p.startY.toFixed(1)} F3       ; Move to Start Position`,
                `G1 Z${(-p.depth).toFixed(1)} F2   ; Plunge to target depth`,
                `G1 Y${cutDistance.toFixed(1)} F2    ; Perform the cut`,
                `G0 Z${p.depth.toFixed(1)} F3    ; Retract`,
                `G0 Y${(-p.endY).toFixed(1)} F3    ; Return to Job Origin`,
                '',
                '; Job complete'
            ];
            return lines.join('\n');
        },

        /**
         * Generate G-code for Linear Cut with Passes
         */
        generateLinearPasses(p) {
            const cutDistance = p.endY - p.startY;
            const lines = [
                '; Linear Cut with Passes',
                '; Generated by Cut Planner',
                '; Target Pieces: 1 (Linear Pass)',
                '',
                'G91              ; Relative positioning',
                `G0 Y${p.startY.toFixed(1)} F3       ; Move to Start Position`
            ];

            let totalZ = 0;
            let atStart = true; // true = at startY, false = at endY

            while (totalZ < p.totalDepth) {
                // Forward pass step
                let forwardStep = Math.min(p.forwardPass, p.totalDepth - totalZ);
                totalZ += forwardStep;

                lines.push('');
                lines.push(`; Pass at cumulative depth -${totalZ.toFixed(1)}`);
                lines.push(`G1 Z${(-forwardStep).toFixed(1)} F2   ; Plunge`);

                if (atStart) {
                    lines.push(`G1 Y${cutDistance.toFixed(1)} F2        ; Cut forward to End Y`);
                    atStart = false;
                } else {
                    lines.push(`G1 Y${(-cutDistance).toFixed(1)} F2       ; Cut backward to Start Y`);
                    atStart = true;
                }

                if (totalZ >= p.totalDepth) break;

                // Backward pass step (if enabled)
                if (p.backwardPass > 0) {
                    let backwardStep = Math.min(p.backwardPass, p.totalDepth - totalZ);
                    totalZ += backwardStep;

                    lines.push(`G1 Z${(-backwardStep).toFixed(1)} F2  ; Deepen`);
                    if (atStart) {
                        lines.push(`G1 Y${cutDistance.toFixed(1)} F2        ; Cut forward to End Y`);
                        atStart = false;
                    } else {
                        lines.push(`G1 Y${(-cutDistance).toFixed(1)} F2       ; Cut backward to Start Y`);
                        atStart = true;
                    }
                } else {
                    // One-way cutting: retract and return to startY
                    lines.push(`G0 Z${totalZ.toFixed(1)} F3         ; Retract to surface`);
                    if (!atStart) {
                        lines.push(`G0 Y${(-cutDistance).toFixed(1)} F3       ; Return to Start Y`);
                        atStart = true;
                    }
                    lines.push(`G0 Z${(-totalZ).toFixed(1)} F3        ; Return to depth`);
                }
            }

            // Final retract and return to Job Origin (0,0)
            lines.push('');
            lines.push(`G0 Z${totalZ.toFixed(1)} F3             ; Retract to surface`);
            if (!atStart) {
                // Currently at endY
                lines.push(`G0 Y${(-p.endY).toFixed(1)} F3           ; Return to Job Origin (0)`);
            } else {
                // Currently at startY
                lines.push(`G0 Y${(-p.startY).toFixed(1)} F3         ; Return to Job Origin (0)`);
            }
            lines.push('');
            lines.push('; Job complete');

            return lines.join('\n');
        },

        /**
         * Generate G-code for Parallel Cuts
         */
        generateParallel(p) {
            const cutDistance = p.endY - p.startY;
            const totalXMove = p.xStep + p.bladeThickness;
            const lines = [
                '; Parallel Cuts',
                '; Generated by Cut Planner',
                `; Target Pieces: ${p.numPieces}`,
                '',
                'G91              ; Relative positioning'
            ];

            for (let i = 0; i < p.numCuts; i++) {
                lines.push('');
                lines.push(`; --- Cut ${i + 1} of ${p.numCuts} ---`);
                lines.push(`G0 Y${p.startY.toFixed(1)} F3       ; Move to Start Y`);
                lines.push(`G1 Z${(-p.depth).toFixed(1)} F2   ; Plunge`);
                lines.push(`G1 Y${cutDistance.toFixed(1)} F2    ; Cut to End Y`);
                lines.push(`G0 Z${p.depth.toFixed(1)} F3    ; Retract`);
                lines.push(`G0 Y${(-p.endY).toFixed(1)} F3    ; Return to Origin Y`);

                if (i < p.numCuts - 1) {
                    lines.push(`G0 X${totalXMove.toFixed(1)} F3       ; Move to next piece (+ blade thickness)`);
                }
            }

            lines.push('');
            lines.push('; Job complete');
            return lines.join('\n');
        },

        /**
         * Generate G-code for Parallel Cuts with Passes
         */
        generateParallelPasses(p) {
            const cutDistance = p.endY - p.startY;
            const totalXMove = p.xStep + p.bladeThickness;
            const lines = [
                '; Parallel Cuts with Passes',
                '; Generated by Cut Planner',
                `; Target Pieces: ${p.numPieces}`,
                '',
                'G91              ; Relative positioning'
            ];

            for (let cut = 0; cut < p.numCuts; cut++) {
                lines.push('');
                lines.push(`; === Parallel Cut ${cut + 1} of ${p.numCuts} ===`);
                lines.push(`G0 Y${p.startY.toFixed(1)} F3       ; Move to Start Y`);

                let totalZ = 0;
                let atStart = true;

                while (totalZ < p.totalDepth) {
                    let forwardStep = Math.min(p.forwardPass, p.totalDepth - totalZ);
                    totalZ += forwardStep;
                    lines.push(`G1 Z${(-forwardStep).toFixed(1)} F2   ; Plunge`);

                    if (atStart) {
                        lines.push(`G1 Y${cutDistance.toFixed(1)} F2        ; Cut forward`);
                        atStart = false;
                    } else {
                        lines.push(`G1 Y${(-cutDistance).toFixed(1)} F2       ; Cut backward`);
                        atStart = true;
                    }

                    if (totalZ >= p.totalDepth) break;

                    if (p.backwardPass > 0) {
                        let backwardStep = Math.min(p.backwardPass, p.totalDepth - totalZ);
                        totalZ += backwardStep;
                        lines.push(`G1 Z${(-backwardStep).toFixed(1)} F2  ; Deepen`);
                        if (atStart) {
                            lines.push(`G1 Y${cutDistance.toFixed(1)} F2        ; Cut forward`);
                            atStart = false;
                        } else {
                            lines.push(`G1 Y${(-cutDistance).toFixed(1)} F2       ; Cut backward`);
                            atStart = true;
                        }
                    } else {
                        lines.push(`G0 Z${totalZ.toFixed(1)} F3         ; Retract`);
                        if (!atStart) {
                            lines.push(`G0 Y${(-cutDistance).toFixed(1)} F3       ; Return to Start Y`);
                            atStart = true;
                        }
                        lines.push(`G0 Z${(-totalZ).toFixed(1)} F3        ; Depth`);
                    }
                }

                lines.push(`G0 Z${totalZ.toFixed(1)} F3             ; Retract`);
                if (!atStart) {
                    lines.push(`G0 Y${(-p.endY).toFixed(1)} F3           ; Return to Origin Y`);
                } else {
                    lines.push(`G0 Y${(-p.startY).toFixed(1)} F3         ; Return to Origin Y`);
                }

                if (cut < p.numCuts - 1) {
                    lines.push(`G0 X${totalXMove.toFixed(1)} F3               ; Next piece (+ blade thickness)`);
                }
            }

            lines.push('');
            lines.push('; Job complete');
            return lines.join('\n');
        },

        /**
         * Generate G-code for the specified job type
         */
        generate(jobType) {
            const params = this.getParams(jobType);
            switch (jobType) {
                case 'single': return this.generateSingle(params);
                case 'linear-passes': return this.generateLinearPasses(params);
                case 'parallel': return this.generateParallel(params);
                case 'parallel-passes': return this.generateParallelPasses(params);
                default: return '; Unknown job type';
            }
        },

        /**
         * Show preview modal
         */
        preview(jobType) {
            this.currentJobType = jobType;
            this.generatedGcode = this.generate(jobType);
            document.getElementById('gcode-preview-content').textContent = this.generatedGcode;
            document.getElementById('gcode-preview-modal').classList.remove('hidden');
            document.getElementById('gcode-preview-run').onclick = () => {
                this.closePreview();
                this.executeGcode(this.generatedGcode);
            };
        },

        closePreview() {
            document.getElementById('gcode-preview-modal').classList.add('hidden');
        },

        run(jobType) {
            const gcode = this.generate(jobType);
            if (confirm(window.i18n?.t('cut_planner.confirm_run') || 'Run this cutting job now?')) {
                this.executeGcode(gcode);
            }
        },

        async executeGcode(gcode) {
            try {
                const lines = gcode.split('\n')
                    .map(l => l.split(';')[0].trim())
                    .filter(l => l);

                AlertManager.add(window.i18n?.t('cut_planner.starting_job') || 'Starting...', 'info', 2000);

                for (const line of lines) {
                    if (line.startsWith('G0') || line.startsWith('G1')) {
                        await this.waitForIdle();
                    }
                    const response = await fetch('/api/gcode', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command: line })
                    });
                    if (!response.ok) throw new Error(`API error`);
                }
                await this.waitForIdle();
                AlertManager.add(window.i18n?.t('cut_planner.job_completed') || 'Done!', 'success', 3000);
            } catch (error) {
                AlertManager.add(`Error: ${error.message}`, 'error', 5000);
            }
        },

        async waitForIdle() {
            return new Promise((resolve) => {
                const start = Date.now();
                const check = () => {
                    const isMoving = typeof AppState !== 'undefined' && AppState.data?.motion?.moving;
                    if (!isMoving || Date.now() - start > 30000) {
                        setTimeout(resolve, 100);
                    } else {
                        setTimeout(check, 100);
                    }
                };
                setTimeout(check, 50);
            });
        }
    };
}

// Initialize
if (document.readyState === 'complete') {
    CutPlanner.init();
} else {
    document.addEventListener('DOMContentLoaded', () => CutPlanner.init());
}
