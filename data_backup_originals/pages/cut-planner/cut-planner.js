/**
 * Cut Planner - G-code generation for operator-friendly cutting jobs
 */

const CutPlanner = {
    safeZ: 0,           // Captured at page load from current Z position
    currentJobType: null,
    generatedGcode: '',

    init() {
        console.log('[CutPlanner] Initializing...');
        this.captureSafeZ();
    },

    /**
     * Capture safe Z from current telemetry position
     */
    captureSafeZ() {
        if (window.AppState && AppState.telemetry && AppState.telemetry.motion) {
            this.safeZ = AppState.telemetry.motion.position?.z || 0;
            console.log('[CutPlanner] Safe Z captured:', this.safeZ);
        } else {
            // Fallback: fetch from API
            fetch('/api/status')
                .then(r => r.json())
                .then(data => {
                    this.safeZ = data.motion?.position?.z || 0;
                    console.log('[CutPlanner] Safe Z from API:', this.safeZ);
                })
                .catch(() => {
                    console.warn('[CutPlanner] Could not capture Safe Z, using 0');
                    this.safeZ = 0;
                });
        }
    },

    /**
     * Get form values for a job type
     */
    getParams(jobType) {
        switch (jobType) {
            case 'single':
                return {
                    startY: parseFloat(document.getElementById('single-start-y').value),
                    endY: parseFloat(document.getElementById('single-end-y').value),
                    depth: parseFloat(document.getElementById('single-depth').value)
                };
            case 'linear-passes':
                return {
                    startY: parseFloat(document.getElementById('passes-start-y').value),
                    endY: parseFloat(document.getElementById('passes-end-y').value),
                    totalDepth: parseFloat(document.getElementById('passes-total-depth').value),
                    forwardPass: parseFloat(document.getElementById('passes-forward').value),
                    backwardPass: parseFloat(document.getElementById('passes-backward').value)
                };
            case 'parallel':
                return {
                    startY: parseFloat(document.getElementById('parallel-start-y').value),
                    endY: parseFloat(document.getElementById('parallel-end-y').value),
                    depth: parseFloat(document.getElementById('parallel-depth').value),
                    numCuts: parseInt(document.getElementById('parallel-num-cuts').value),
                    xStep: parseFloat(document.getElementById('parallel-x-step').value)
                };
            case 'parallel-passes':
                return {
                    startY: parseFloat(document.getElementById('pp-start-y').value),
                    endY: parseFloat(document.getElementById('pp-end-y').value),
                    totalDepth: parseFloat(document.getElementById('pp-total-depth').value),
                    forwardPass: parseFloat(document.getElementById('pp-forward').value),
                    backwardPass: parseFloat(document.getElementById('pp-backward').value),
                    numCuts: parseInt(document.getElementById('pp-num-cuts').value),
                    xStep: parseFloat(document.getElementById('pp-x-step').value)
                };
            default:
                return {};
        }
    },

    /**
     * Generate G-code for Single Linear Cut
     */
    generateSingle(p) {
        const lines = [
            '; Single Linear Cut',
            '; Generated by Cut Planner',
            '',
            'G90              ; Absolute positioning',
            `G0 Z${this.safeZ}       ; Move to safe height`,
            `G0 Y${p.startY}         ; Move to start position`,
            `G1 Z${this.safeZ - p.depth} F2  ; Plunge to depth`,
            `G1 Y${p.endY} F2        ; Cut forward`,
            `G0 Z${this.safeZ}       ; Retract to safe height`,
            `G0 Y${p.startY}         ; Rapid return to start`,
            '',
            '; Job complete'
        ];
        return lines.join('\n');
    },

    /**
     * Generate G-code for Linear Cut with Passes
     */
    generateLinearPasses(p) {
        const lines = [
            '; Linear Cut with Passes',
            '; Generated by Cut Planner',
            '',
            'G90              ; Absolute positioning',
            `G0 Z${this.safeZ}       ; Move to safe height`,
            `G0 Y${p.startY}         ; Move to start position`
        ];

        let currentZ = this.safeZ;
        let atStart = true;

        while ((this.safeZ - currentZ) < p.totalDepth) {
            // Forward pass
            currentZ -= p.forwardPass;
            if ((this.safeZ - currentZ) > p.totalDepth) {
                currentZ = this.safeZ - p.totalDepth; // Clamp to total depth
            }

            lines.push('');
            lines.push(`; Pass at Z${currentZ.toFixed(1)}`);
            lines.push(`G1 Z${currentZ.toFixed(1)} F2  ; Plunge`);

            if (atStart) {
                lines.push(`G1 Y${p.endY} F2        ; Cut forward`);
                atStart = false;
            } else {
                lines.push(`G1 Y${p.startY} F2      ; Cut backward`);
                atStart = true;
            }

            // Check if we've reached total depth
            if ((this.safeZ - currentZ) >= p.totalDepth) break;

            // Backward pass (if enabled)
            if (p.backwardPass > 0) {
                currentZ -= p.backwardPass;
                if ((this.safeZ - currentZ) > p.totalDepth) {
                    currentZ = this.safeZ - p.totalDepth;
                }

                lines.push(`G1 Z${currentZ.toFixed(1)} F2  ; Deepen`);
                if (atStart) {
                    lines.push(`G1 Y${p.endY} F2        ; Cut forward`);
                    atStart = false;
                } else {
                    lines.push(`G1 Y${p.startY} F2      ; Cut backward`);
                    atStart = true;
                }
            } else {
                // No backward pass - retract and return
                lines.push(`G0 Z${this.safeZ}       ; Retract`);
                lines.push(`G0 Y${p.startY}         ; Return to start`);
                atStart = true;
            }
        }

        lines.push('');
        lines.push(`G0 Z${this.safeZ}       ; Retract to safe height`);
        lines.push('');
        lines.push('; Job complete');

        return lines.join('\n');
    },

    /**
     * Generate G-code for Parallel Cuts
     */
    generateParallel(p) {
        const lines = [
            '; Parallel Cuts',
            '; Generated by Cut Planner',
            '',
            'G90              ; Absolute positioning',
            `G0 Z${this.safeZ}       ; Move to safe height`
        ];

        let currentX = 0; // Starting X position (relative to current)

        for (let i = 0; i < p.numCuts; i++) {
            lines.push('');
            lines.push(`; Cut ${i + 1} of ${p.numCuts}`);

            if (i > 0) {
                currentX += p.xStep;
                lines.push(`G0 X${currentX.toFixed(1)}  ; Step to next position`);
            }

            lines.push(`G0 Y${p.startY}         ; Move to start`);
            lines.push(`G1 Z${this.safeZ - p.depth} F2  ; Plunge`);
            lines.push(`G1 Y${p.endY} F2        ; Cut`);
            lines.push(`G0 Z${this.safeZ}       ; Retract`);
        }

        lines.push('');
        lines.push('; Job complete');

        return lines.join('\n');
    },

    /**
     * Generate G-code for Parallel Cuts with Passes
     */
    generateParallelPasses(p) {
        const lines = [
            '; Parallel Cuts with Passes',
            '; Generated by Cut Planner',
            '',
            'G90              ; Absolute positioning',
            `G0 Z${this.safeZ}       ; Move to safe height`
        ];

        let currentX = 0;

        for (let cut = 0; cut < p.numCuts; cut++) {
            lines.push('');
            lines.push(`; === Cut ${cut + 1} of ${p.numCuts} ===`);

            if (cut > 0) {
                currentX += p.xStep;
                lines.push(`G0 X${currentX.toFixed(1)}  ; Step to next cut position`);
            }

            lines.push(`G0 Y${p.startY}         ; Move to start`);

            // Passes for this cut
            let currentZ = this.safeZ;
            let atStart = true;

            while ((this.safeZ - currentZ) < p.totalDepth) {
                // Forward pass
                currentZ -= p.forwardPass;
                if ((this.safeZ - currentZ) > p.totalDepth) {
                    currentZ = this.safeZ - p.totalDepth;
                }

                lines.push(`G1 Z${currentZ.toFixed(1)} F2`);
                if (atStart) {
                    lines.push(`G1 Y${p.endY} F2`);
                    atStart = false;
                } else {
                    lines.push(`G1 Y${p.startY} F2`);
                    atStart = true;
                }

                if ((this.safeZ - currentZ) >= p.totalDepth) break;

                // Backward pass
                if (p.backwardPass > 0) {
                    currentZ -= p.backwardPass;
                    if ((this.safeZ - currentZ) > p.totalDepth) {
                        currentZ = this.safeZ - p.totalDepth;
                    }

                    lines.push(`G1 Z${currentZ.toFixed(1)} F2`);
                    if (atStart) {
                        lines.push(`G1 Y${p.endY} F2`);
                        atStart = false;
                    } else {
                        lines.push(`G1 Y${p.startY} F2`);
                        atStart = true;
                    }
                } else {
                    lines.push(`G0 Z${this.safeZ}`);
                    lines.push(`G0 Y${p.startY}`);
                    atStart = true;
                }
            }

            lines.push(`G0 Z${this.safeZ}       ; Retract after cut`);
        }

        lines.push('');
        lines.push('; Job complete');

        return lines.join('\n');
    },

    /**
     * Generate G-code for the specified job type
     */
    generate(jobType) {
        const params = this.getParams(jobType);

        switch (jobType) {
            case 'single':
                return this.generateSingle(params);
            case 'linear-passes':
                return this.generateLinearPasses(params);
            case 'parallel':
                return this.generateParallel(params);
            case 'parallel-passes':
                return this.generateParallelPasses(params);
            default:
                return '; Unknown job type';
        }
    },

    /**
     * Show preview modal
     */
    preview(jobType) {
        this.currentJobType = jobType;
        this.generatedGcode = this.generate(jobType);

        document.getElementById('gcode-preview-content').textContent = this.generatedGcode;
        document.getElementById('gcode-preview-modal').classList.remove('hidden');

        // Set up run button in modal
        document.getElementById('gcode-preview-run').onclick = () => {
            this.closePreview();
            this.executeGcode(this.generatedGcode);
        };
    },

    /**
     * Close preview modal
     */
    closePreview() {
        document.getElementById('gcode-preview-modal').classList.add('hidden');
    },

    /**
     * Run job directly (no preview)
     */
    run(jobType) {
        const gcode = this.generate(jobType);

        if (confirm('Run this cutting job now?')) {
            this.executeGcode(gcode);
        }
    },

    /**
     * Send G-code to execution API
     */
    async executeGcode(gcode) {
        try {
            // Send each line to the G-code API
            const lines = gcode.split('\n').filter(l => l.trim() && !l.trim().startsWith(';'));

            AlertManager.add('Starting cut job...', 'info', 2000);

            for (const line of lines) {
                const response = await fetch('/api/gcode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: line })
                });

                if (!response.ok) {
                    throw new Error(`Failed to execute: ${line}`);
                }

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'Execution failed');
                }
            }

            AlertManager.add('Cut job completed!', 'success', 3000);
        } catch (error) {
            console.error('[CutPlanner] Execution error:', error);
            AlertManager.add(`Job failed: ${error.message}`, 'error', 5000);
        }
    }
};

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => CutPlanner.init());
// Also init if loaded dynamically by router
if (document.readyState === 'complete') {
    CutPlanner.init();
}
